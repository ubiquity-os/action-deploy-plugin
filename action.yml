name: "Update Manifest and Commit Changes"
description: "Checks out the repository, sets up Node, installs dependencies, updates manifest.json, formats, and commits/pushes changes signing the commit."
inputs:
  manifestPath:
    description: "The path to the manifest.json file."
    required: false
    default: "${{ github.workspace }}/manifest.json"
  schemaPath:
    description: "The path to the plugin settings schema."
    required: false
    default: "${{ github.workspace }}/src/types/plugin-input.ts"
  pluginEntry:
    description: "The path to the plugin entry file."
    required: false
    default: "${{ github.workspace }}/src/index.ts"
  commitMessage:
    description: "The commit message."
    required: false
    default: "chore: [skip ci] updated manifest.json and dist build"
  nodeVersion:
    description: "The version of Node.js to use."
    default: "20.10.0"
  treatAsEsm:
    description: "If the package is set to be treated as ESM, it will replace __dirname occurrences."
    default: "false"
  sourcemap:
    description: "Generates the sourcemap for the compiled files"
outputs: {}
runs:
  using: "composite"
  steps:
    - name: Detect GitHub App credentials
      id: detect-app
      shell: bash
      run: |
        if [[ -n "${APP_ID:-}" && -n "${APP_PRIVATE_KEY:-}" ]]; then
          echo "has_app=true" >> "$GITHUB_OUTPUT"
        else
          echo "has_app=false" >> "$GITHUB_OUTPUT"
        fi

    - name: Create GitHub App token
      id: app-token
      if: steps.detect-app.outputs.has_app == 'true'
      uses: actions/create-github-app-token@v2
      with:
        app-id: ${{ env.APP_ID }}
        private-key: ${{ env.APP_PRIVATE_KEY }}

    - name: Validate GitHub App token
      shell: bash
      if: steps.detect-app.outputs.has_app == 'true'
      run: |
        if [[ -z "${{ steps.app-token.outputs.token }}" ]]; then
          echo "Failed to generate GitHub App token."
          exit 1
        fi

    - name: Get GitHub App User ID
      id: get-user-id
      if: steps.detect-app.outputs.has_app == 'true'
      shell: bash
      run: echo "user-id=$(gh api "/users/${{ steps.app-token.outputs.app-slug }}[bot]" --jq .id)" >> "$GITHUB_OUTPUT"
      env:
        GH_TOKEN: ${{ steps.app-token.outputs.token }}

    - name: Check out the repository
      uses: actions/checkout@v4

    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ inputs.nodeVersion }}

    - uses: oven-sh/setup-bun@v2

    - name: Install dependencies
      shell: bash
      run: |
        bun install --frozen-lockfile

    - name: Build project
      shell: bash
      run: |
        bun add -DE @vercel/ncc
        echo "Deleting previous dist..."
        rm -rf "${{ github.workspace }}/dist"
        echo "Compiling plugin..."
        bun ncc build ${{ inputs.pluginEntry }} --external "./tests" -m ${{ inputs.sourcemap == 'true' && '-s' || '' }} -o dist/plugin
        echo "Compiling plugin types..."
        bun ncc build ${{ inputs.schemaPath }} --external "./tests" -m -o plugin

    - name: Replace __dirname with import.meta.dirname
      if: ${{ inputs.treatAsEsm }}
      shell: bash
      run: |
        if [ "${{ inputs.treatAsEsm }}" = "true" ]; then
          sed -i 's/__dirname/import.meta.dirname/g' "${{ github.workspace }}/dist/plugin/index.js"
        fi

    - name: Update manifest configuration JSON
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs').promises;
          const path = require('path');

          async function updateManifest() {
            const manifestPath = '${{ inputs.manifestPath }}';
            const pluginPath = path.resolve('${{ github.workspace }}', 'plugin', 'index.js');

            let pluginSettingsSchema;
            try {
              // First, try to load as ESM
              try {
                const pluginModule = await import(`file://${pluginPath}`);
                pluginSettingsSchema = pluginModule.pluginSettingsSchema;

                if (!pluginSettingsSchema) {
                  throw new Error('pluginSettingsSchema not found in the ESM module');
                }
              } catch (esmError) {
                // If ESM import fails, try loading as CJS
                try {
                  const pluginModule = require(pluginPath);
                  pluginSettingsSchema = pluginModule.pluginSettingsSchema;

                  if (!pluginSettingsSchema) {
                    throw new Error('pluginSettingsSchema not found in the CJS module');
                  }
                } catch (cjsError) {
                  console.error('Error loading module as ESM and CJS:', esmError, cjsError);
                  process.exit(1);
                }
              }
            } catch (error) {
              console.error('Error loading module:', error);
              process.exit(1);
            }

            const manifest = JSON.parse(await fs.readFile(manifestPath, 'utf8'));
            manifest["configuration"] = pluginSettingsSchema;

            function customReviver(key, value) {
              if (typeof value === "object" && value !== null) {
                if ("properties" in value && "required" in value) {
                  const requiredFields = new Set(value.required);
                  for (const [propKey, propValue] of Object.entries(value.properties)) {
                    if (typeof propValue === 'object' && 'default' in propValue) {
                      requiredFields.delete(propKey);
                    }
                  }
                  value.required = Array.from(requiredFields);
                  if (value.required.length === 0) {
                    delete value.required;
                  }
                }

                // Recursively apply to nested objects and arrays
                if (Array.isArray(value)) {
                  return value.map(item => JSON.parse(JSON.stringify(item), customReviver));
                } else {
                  return Object.fromEntries(
                    Object.entries(value).map(([k, v]) => [k, JSON.parse(JSON.stringify(v), customReviver)])
                  );
                }
              }
              return value;
            }

            const updatedManifest = JSON.stringify(manifest, customReviver, 2);
            await fs.writeFile(manifestPath, updatedManifest, 'utf8');
          }
          updateManifest();

    - name: Format manifest using Prettier
      shell: bash
      run: |
        npx prettier --write "${{ inputs.manifestPath }}"

    - name: Inject reassembly code into dist/index.js
      shell: bash
      env:
        TREAT_AS_ESM: ${{ inputs.treatAsEsm }}
      run: |
        if [[ "${TREAT_AS_ESM}" == "true" ]]; then
          cp "${{ github.action_path }}/.github/scripts/reassembly-esm.js" dist/index.js
          cp dist/plugin/package.json dist/package.json
        else
          cp "${{ github.action_path }}/.github/scripts/reassembly-cjs.js" dist/index.js
        fi

    - name: Prepare commit authentication info
      id: auth-info
      shell: bash
      run: |
        if [[ "${{ steps.detect-app.outputs.has_app }}" == "true" ]]; then
          echo "token=${{ steps.app-token.outputs.token }}" >> "$GITHUB_OUTPUT"
          echo "app_slug=${{ steps.app-token.outputs.app-slug }}" >> "$GITHUB_OUTPUT"
          echo "user_id=${{ steps.get-user-id.outputs.user-id }}" >> "$GITHUB_OUTPUT"
          echo "use_app=true" >> "$GITHUB_OUTPUT"
        else
          echo "token=${{ secrets.GITHUB_TOKEN }}" >> "$GITHUB_OUTPUT"
          echo "app_slug=github-actions" >> "$GITHUB_OUTPUT"
          echo "user_id=41898282" >> "$GITHUB_OUTPUT"
          echo "use_app=false" >> "$GITHUB_OUTPUT"
        fi

    - name: Validate commit credentials
      shell: bash
      env:
        TOKEN: ${{ steps.auth-info.outputs.token }}
      run: |
        if [[ -z "${TOKEN}" ]]; then
          echo "Missing commit token; aborting."
          exit 1
        fi

    - name: Update manifest.json and dist folder
      shell: bash
      env:
        GITHUB_TOKEN: ${{ steps.auth-info.outputs.token }}
        COMMIT_MESSAGE: ${{ inputs.commitMessage }}
        MANIFEST_PATH: ${{ inputs.manifestPath }}
        GITHUB_WORKSPACE: ${{ github.workspace }}
        APP_SLUG: ${{ steps.auth-info.outputs.app_slug }}
        APP_USER_ID: ${{ steps.auth-info.outputs.user_id }}
        USE_APP_TOKEN: ${{ steps.auth-info.outputs.use_app }}
      run: |
        set -euo pipefail

        if [[ -z "${APP_SLUG}" || -z "${APP_USER_ID}" ]]; then
          echo "Missing GitHub App identity; aborting commit."
          exit 1
        fi

        # Retry function for git operations
        retry_git_operation() {
          local operation="$1"
          local max_attempts=5
          local attempt=1
          local base_delay=10
          local max_delay=300

          while [[ $attempt -le $max_attempts ]]; do
            echo "Attempting git operation: $operation (attempt $attempt/$max_attempts)"

            if eval "$operation"; then
              echo "Git operation succeeded on attempt $attempt"
              return 0
            else
              local exit_code=$?
              echo "Git operation failed on attempt $attempt with exit code $exit_code"

              if [[ $attempt -eq $max_attempts ]]; then
                echo "All retry attempts exhausted. Final failure."
                return $exit_code
              fi

              # Calculate exponential backoff with jitter
              local delay=$((base_delay * (2 ** (attempt - 1))))
              if [[ $delay -gt $max_delay ]]; then
                delay=$max_delay
              fi
              # Add jitter (Â±25%)
              local jitter=$((RANDOM % (delay / 2)))
              delay=$((delay + jitter - (delay / 4)))
              if [[ $delay -lt 1 ]]; then
                delay=1
              fi

              echo "Waiting ${delay} seconds before retry..."
              sleep $delay
              ((attempt++))
            fi
          done
        }

        if [[ "${USE_APP_TOKEN}" == "true" ]]; then
          git config --global user.name "${APP_SLUG}[bot]"
          git config --global user.email "${APP_USER_ID}+${APP_SLUG}[bot]@users.noreply.github.com"
        else
          git config --global user.name "github-actions[bot]"
          git config --global user.email "41898282+github-actions[bot]@users.noreply.github.com"
        fi

        git remote set-url origin "https://x-access-token:${GITHUB_TOKEN}@github.com/${GITHUB_REPOSITORY}.git"

        # Stage files
        git add "${MANIFEST_PATH}"

        if [[ -d "${GITHUB_WORKSPACE}/dist" ]]; then
          find "${GITHUB_WORKSPACE}/dist" \( -name "*.js" -o -name "*.cjs" -o -name "*.map" -o -name "*.json" \) -print0 | xargs -0 git add -f
        fi

        if [[ -d "${GITHUB_WORKSPACE}/dist/plugin" ]]; then
          find "${GITHUB_WORKSPACE}/dist/plugin" \( -name "*.js" -o -name "*.cjs" -o -name "*.map" -o -name "*.json" \) -print0 | xargs -0 git add -f
        fi

        echo "Checking for staged changes..."
        # Check if git add actually staged anything
        if ! git diff --cached --quiet; then
          echo "Changes detected. Committing and pushing with retry logic..."

          # Commit with retry
          retry_git_operation "git commit -m \"${COMMIT_MESSAGE}\""

          # Push with retry
          retry_git_operation "git push"

          echo "Changes committed and pushed successfully."
        else
          echo "No changes detected in manifest or dist folder."
        fi
